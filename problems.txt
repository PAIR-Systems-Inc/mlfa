from O365 import Account, FileSystemTokenBackend
from dotenv import load_dotenv
from datetime import datetime, timezone, timedelta
import os, time, json, re, logging, random  # UPDATED: added random
from bs4 import BeautifulSoup
from datetime import datetime, timedelta
import requests

# -------------------------------
# INIT / CONSTANTS
# -------------------------------
load_dotenv()
BASE_DIR = os.path.dirname(os.path.abspath(__file__))

# Start from now - only process new emails going forward
START_TIME = datetime.now(timezone.utc) - timedelta(days=4)

CLIENT_ID = "c0abfd02-2166-4a52-b052-16d1aa084afb"  # MLFA app registration
CLIENT_SECRET = os.getenv("O365_CLIENT_SECRET")
TENANT_ID = os.getenv("O365_TENANT_ID")
REPLY_ID_TAG = "Pair_Reply_Reference_ID"

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
EMAIL_TO_WATCH = os.getenv("EMAIL_TO_WATCH")

PENDING_TAG = "PAIRActioned/pending_review"

EMAILS_TO_FORWARD = ['Mujahid.rasul@mlfa.org', 'Syeda.sadiqa@mlfa.org', 'Arshia.ali.khan@mlfa.org', 'Maria.laura@mlfa.org', 'info@mlfa.org', 'aisha.ukiu@mlfa.org', 'shawn@strategichradvisory.com', 'Marium.Uddin@mlfa.org']
NONREAD_CATEGORIES = {"marketing"}  # Keep these unread
SKIP_CATEGORIES = {'spam', 'cold_outreach', 'newsletter', 'irrelevant_other'}

HUMAN_CHECK = True  # Enable human check for approval hub

# Storage for multiple pending emails
pending_emails = {}  # Dictionary to store multiple emails by ID
current_email_id = None  # Track which email is currently being shown

# Storage for forwarded email recipients (for CC functionality)
forwarded_recipients = {}  # Maps message_id to list of recipients

# -------------------------------
# OPENAI CLIENT
# -------------------------------
from openai import OpenAI
client = OpenAI(api_key=OPENAI_API_KEY)

# -------------------------------
# AUTH / ACCOUNT
# -------------------------------
IS_PRODUCTION = os.getenv('ENVIRONMENT', 'development').lower() == 'production'

if IS_PRODUCTION and CLIENT_SECRET:
    credentials = (CLIENT_ID, CLIENT_SECRET)
    account = Account(credentials, auth_flow_type="credentials", tenant_id=TENANT_ID)
    if not account.is_authenticated:
        account.authenticate()
else:
    credentials = (CLIENT_ID, None)
    token_backend = FileSystemTokenBackend(token_path=".", token_filename="o365_token.txt")
    account = Account(credentials, auth_flow_type="authorization", token_backend=token_backend, tenant_id=TENANT_ID)
    if not account.is_authenticated:
        account.authenticate(scopes=['basic', 'message_all'])

mailbox = account.mailbox(resource=EMAIL_TO_WATCH)
inbox_folder = mailbox.inbox_folder()
junk_folder = mailbox.junk_folder()

# UPDATED: track last successful auth time for proactive renewal
last_auth_time = time.time()

# -------------------------------
# DELTA TOKEN I/O (robust)
# -------------------------------
def read_token(path):
    if os.path.exists(path):
        with open(path, "r") as f:
            content = f.read().strip()
            return content or None  # UPDATED: normalize empty -> None
    return None

def load_last_delta():
    inbox_token_path = os.path.join(BASE_DIR, "delta_token_inbox.txt")
    junk_token_path = os.path.join(BASE_DIR, "delta_token_junk.txt")
    inbox_token = read_token(inbox_token_path)
    junk_token = read_token(junk_token_path)
    return inbox_token, junk_token  # may be None

def save_last_delta(inbox_token, junk_token):
    """
    UPDATED: Always write files so we can CLEAR a stale token by writing empty.
    Pass None to clear (write empty).
    """
    inbox_token_path = os.path.join(BASE_DIR, "delta_token_inbox.txt")
    junk_token_path  = os.path.join(BASE_DIR, "delta_token_junk.txt")
    try:
        with open(inbox_token_path, "w") as f:
            f.write(inbox_token or "")
        with open(junk_token_path, "w") as f:
            f.write(junk_token or "")
    except IOError as e:
        print(f"‚ö†Ô∏è CRITICAL: Could not save delta token to file! Error: {e}")

# -------------------------------
# CLASSIFIER
# -------------------------------
def classify_email(subject, body):
    prompt = f"""You are an email routing assistant for MLFA (Muslim Legal Fund of America), a nonprofit organization focused on legal advocacy for Muslims in the United States.

    Your job is to classify incoming emails based on their **content, sender intent, and relevance** to MLFA‚Äôs mission. Do not rely on keywords alone. Use the routing rules below to assign one or more categories and determine appropriate recipients if applicable.
    Additionally, **identify the sender‚Äôs name** when possible and include it as `name_sender` in the JSON. Prefer the ‚ÄúFrom‚Äù display name; if unavailable or generic, use a clear sign-off/signature in the body. If you cannot determine the name confidently, set `name_sender` to `"Sender"`.

    HUMAN-STYLE REPLY ESCALATION (IMPORTANT):
    Flag emails that should NOT get a generic auto-reply because they are personal/referral-like or contain substantial case detail.
    Set `needs_personal_reply=true` if ANY of these are present:
    - **Referral signals:** mentions of being referred by a person/org (e.g., imam, attorney, community leader, ‚ÄúX told me to contact you,‚Äù CC‚Äôing a referrer).
    - **Personal narrative with specifics:** detailed timeline, names, dates, locations, docket/case numbers, court filings, detention/deportation details, attorney names, or attached evidence.
    - **Clearly individualized appeal:** tone reads as one-to-one help-seeking rather than a form blast.
    - **Brevity & Generic Content safeguard:** If the email is *short, vague, and generic* (e.g., ‚ÄúI need legal help‚Äù or ‚ÄúPlease assist‚Äù), and does **not** include referral language or specific personal details, then set `needs_personal_reply=false` even if it asks for help.

    If none of the above apply, set `needs_personal_reply=false`.

    ROUTING RULES & RECIPIENTS:

    - **Legal inquiries** ‚Üí If someone is explicitly **asking for legal help or representation**, categorize as `"legal"`. These users should be referred to MLFA‚Äôs "Apply for Help" form (no forwarding needed).

    - **Donor-related inquiries** ‚Üí Categorize as `"donor"` only if the **sender is a donor** or is asking about a **specific donation**, such as issues with payment, receipts, or donation follow-ups. Forward to:
    Mujahid.rasul@mlfa.org, Syeda.sadiqa@mlfa.org

    - **Sponsorship requests** ‚Üí If someone is **requesting sponsorship or financial support from MLFA**, categorize as `"sponsorship"`. Forward to:
    Arshia.ali.khan@mlfa.org, Maria.laura@mlfa.org

    - **Fellowship inquiries** ‚Üí If someone is **applying for, asking about, or offering a fellowship** (legal, advocacy, or nonprofit-focused), categorize as `"fellowship"`. Forward to:
    aisha.ukiu@mlfa.org

    - **Organizational questions** ‚Üí If the sender is asking about **MLFA‚Äôs internal operations**, such as leadership, partnerships, or collaboration, categorize as `"organizational"`. Forward to:
    Arshia.ali.khan@mlfa.org, Maria.laura@mlfa.org

    - **Volunteer inquiries** ‚Üí If someone is **offering to volunteer** their time or skills to MLFA **or** is **asking about volunteering** (for themselves or on behalf of someone else), categorize as `"volunteer"`. These will receive an automated reply with the volunteer application form.

    - **Job applications** ‚Üí If someone is **applying for a paid job**, sending a resume, or asking about open employment positions, categorize as `"job_application"`. Forward to:
    shawn@strategichradvisory.com

    - **Internship applications** ‚Üí If someone is **applying for an internship** (paid or unpaid), sending a resume for an internship program, or inquiring about internship opportunities, categorize as `"internship"`. Forward to:
    aisha.ukiu@mlfa.org

    - **Media inquiries** ‚Üí If the sender is a **reporter or journalist asking for comments, interviews, or statements**, categorize as `"media"`. Forward to:
    Marium.Uddin@mlfa.org

    - **Email marketing/sales** ‚Üí If the sender is **offering a product, service, or software**, categorize as `"marketing"` only if:
    1) The offering is **relevant to MLFA‚Äôs nonprofit or legal work**, **and**
    2) The sender shows **clear contextual awareness** (e.g., refers to MLFA‚Äôs legal mission, Muslim families, or nonprofit context), **and**
    3) The product is **niche-specific**, such as legal case management, zakat compliance tools, intake systems for nonprofits, or Islamic legal software.
    Move to the "Sales emails" folder.
    **Do not treat generic, untargeted, or mass-promotional emails as marketing.**

    - **Cold outreach** ‚Üí Any **unsolicited sales email** that lacks clear tailoring to MLFA‚Äôs work. Categorize as `"cold_outreach"` if:
    - The sender shows **no meaningful awareness** of MLFA‚Äôs mission
    - The offer is **broad, mass-marketed, or hype-driven**
    - The email uses commercial hooks like ‚ÄúAct now,‚Äù ‚Äú800% increase,‚Äù ‚ÄúOnly $99/month,‚Äù or ‚ÄúClick here‚Äù
    Even if the topic sounds legal or nonprofit-adjacent, if it **feels generic**, classify it as cold outreach.
    Mark as read; **do not** treat as marketing.

    - **Spam** ‚Üí Obvious scams, phishing, AI-generated nonsense, or malicious intent. Move to Junk.

    - **Newsletter** ‚Üí Bulk content like PR updates, blog digests, or mass announcements not addressed to MLFA directly. Place in "Newsletters" if available.

    - **Irrelevant (other)** ‚Üí Anything that doesn't match the above and is unrelated to MLFA‚Äôs mission ‚Äî e.g., misdirected emails, general inquiries, or off-topic messages. Mark as read and ignore.

    IMPORTANT GUIDELINES:
    1. Focus on **relevance and specificity**, not just keywords. The more the sender understands MLFA, the more likely it is to be legitimate.
    2. If an email is a **niche legal tech offer clearly crafted for MLFA or Muslim nonprofits**, treat it as `"marketing"` ‚Äî even if unsolicited.
    3. If the offer is **generic or clearly sent in bulk**, it‚Äôs `"cold_outreach"` ‚Äî even if it references legal themes or Muslim communities.
    4. Never mark cold outreach or mass sales emails as `"marketing"`, even if they reference MLFA‚Äôs field.
    5. If someone is **offering legal services**, classify as `"organizational"` only if relevant and serious (not promotional).
    6. Emails can and should have **multiple categories** when appropriate (e.g., a donor asking to volunteer ‚Üí `"donor"` and `"volunteer"`).
    7. Use `all_recipients` only for forwarded categories: `"donor"`, `"sponsorship"`, `"fellowship"`, `"organizational"`, `"job_application"`, `"internship"`, `"media"`.
    8. For `"legal"`, `"volunteer"`, `"marketing"`, and all `"irrelevant"` types, leave `all_recipients` empty.

    PRIORITY & TIES:
    - If `"legal"` applies, **still include all other relevant categories** ‚Äî `"legal"` is additive, never exclusive.
    - `"marketing"` vs `"cold_outreach"`: choose only one based on tailoring (see rules above).

    Return a JSON object with:
    - `categories`: array from ["legal","donor","sponsorship","fellowship","organizational","volunteer","job_application","internship","media","marketing","spam","cold_outreach","newsletter","irrelevant_other"]
    - `all_recipients`: list of MLFA email addresses (may be empty)
    - `needs_personal_reply`: boolean per the Escalation section
    - `reason`: dictionary mapping each category to a brief justification
    - `escalation_reason`: brief string explaining why `needs_personal_reply` is true (empty string if false)
    - `name_sender`: the sender‚Äôs name if confidently identified; otherwise exactly `"Sender"`

    Subject: {subject}

    Body:
    {body}
    """
    try:
        response = client.chat.completions.create(
            model="gpt-4.1-mini",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.2,
        )
        raw = response.choices[0].message.content.strip()
        if raw.startswith("```json"): raw = raw[len("```json"):].strip()
        if raw.endswith("```"): raw = raw[:-3].strip()
        parsed_result = json.loads(raw)
        if not isinstance(parsed_result, dict):
            print(f"Warning: AI returned non-dict response: {type(parsed_result)}")
            return {}
        return parsed_result
    except Exception as e:
        print(f"Classification error: {e}")
        return {}

# -------------------------------
# HTTP RETRY WRAPPER (handles 401/403/429)
# -------------------------------
def _get_with_retry(conn, url, params=None, name="INBOX", max_tries=2):
    """
    UPDATED: One-shot retry for auth (401/403) by reconnecting, and throttling (429) by honoring Retry-After.
    Returns the Response (2xx) or the last failure Response.
    """
    tries = 0
    while True:
        tries += 1
        resp = conn.get(url, params=params) if params else conn.get(url)
        code = getattr(resp, "status_code", 0) or 0

        if 200 <= code < 300:
            return resp

        if code in (401, 403) and tries < max_tries:
            print(f"‚ö†Ô∏è {name}: {code} auth error; reconnecting then retrying once‚Ä¶")
            if reconnect_account():
                conn = account.connection
                params = None  # Graph returns absolute URLs after page 1
                continue
            else:
                print(f"‚ùå {name}: reconnect failed.")
                return resp

        if code == 429 and tries < max_tries:
            ra_hdr = (resp.headers.get("Retry-After") or "5").strip()
            try:
                ra = int(ra_hdr)
            except Exception:
                ra = 5
            ra = min(max(ra, 3), 60)
            print(f"‚è≥ {name}: 429 throttled. Sleeping {ra}s then retrying‚Ä¶")
            time.sleep(ra)
            params = None
            continue

        return resp

# -------------------------------
# FOLDER PROCESSOR (delta)
# -------------------------------
def process_folder(folder, name, delta_token_url):
    """
    Uses the Microsoft Graph /delta endpoint directly so we can:
      1) Page through all changes (via @odata.nextLink)
      2) Capture and return the final @odata.deltaLink

    `delta_token_url` should be either:
      - None (first run), or
      - The FULL @odata.deltaLink URL from a previous run (store it as-is).
    """
    import urllib.parse

    # --- Build the initial delta URL ---
    try:
        base_url = getattr(account.protocol, "service_url", None)
        if callable(base_url):
            base_url = account.protocol.service_url()
        if not base_url:
            base_url = "https://graph.microsoft.com/v1.0"
    except Exception:
        base_url = "https://graph.microsoft.com/v1.0"

    if delta_token_url:
        next_url = delta_token_url
        params = None
    else:
        folder_id = getattr(folder, 'object_id', None) or getattr(folder, 'folder_id', None) or getattr(folder, 'id', None)
        user_part = urllib.parse.quote(EMAIL_TO_WATCH)
        next_url = f"{base_url}/users/{user_part}/mailFolders/{folder_id}/messages/delta"
        params = {
            "$select": "id,conversationId,isRead,receivedDateTime,from,sender,subject,categories,uniqueBody,body",
            "$top": "50",
        }
        if START_TIME:
            params["$filter"] = f"receivedDateTime ge {START_TIME.isoformat()}"

    final_delta_link = delta_token_url
    total_changed = 0

    try:
        conn = account.connection

        while next_url:
            # UPDATED: use retry wrapper
            resp = _get_with_retry(account.connection, next_url, params=params, name=name)
            if not resp or resp.status_code // 100 != 2:
                code = getattr(resp, 'status_code', 'n/a')
                body = getattr(resp, 'text', '')
                print(f" Error accessing {name}: {code} {body}")

                # UPDATED: handle delta invalidation -> reset (return None)
                if code == 410 or (code == 400 and ('SyncState' in body or 'delta' in body)):
                    print(f"üîÅ {name}: delta token expired/invalid. Resetting to full resync next tick.")
                    return None

                return delta_token_url or final_delta_link

            data = resp.json() or {}
            items = data.get("value", [])
            print(f"DIAGNOSTIC [{name}]: Page returned {len(items)} item(s).")

            for item in items:
                total_changed += 1
                try:
                    msg = folder.get_message(object_id=item.get("id"))
                except Exception:
                    msg = None

                if not msg:
                    continue

                # ==== BEGIN: existing per-item logic ====
                conv_id = getattr(msg, "conversation_id", None)
                if not conv_id:
                    try:
                        msg.refresh()
                    except Exception:
                        pass
                    if any((c or "").startswith("PAIRActioned") for c in (msg.categories or [])):
                        continue
                    if not msg.is_read:
                        sender_addr = (msg.sender.address or "").lower() if msg.sender else ""
                        sender_is_staff = sender_addr in [e.lower() for e in EMAILS_TO_FORWARD]
                        is_automated_reply = bool(re.search(fr"{REPLY_ID_TAG}\s*([^\s<]+)", msg.body or "", flags=re.I|re.S))
                        if sender_is_staff and is_automated_reply and not any((c or "").startswith("PAIRActioned") for c in (msg.categories or [])):
                            handle_internal_reply(msg)
                            continue

                        body_to_analyze = get_clean_message_text(msg)
                        print(f"\nNEW:  [{name}] {msg.received.strftime('%Y-%m-%d %H:%M')} | "
                              f"{msg.sender.address if msg.sender else 'UNKNOWN'} | {msg.subject}")
                        result = classify_email(msg.subject, body_to_analyze)
                        if HUMAN_CHECK:
                            print(json.dumps(result, indent=2))
                            email_id = msg.object_id
                            if email_id not in pending_emails:
                                pending_emails[email_id] = {
                                    "subject": msg.subject,
                                    "body": body_to_analyze,
                                    "classification": result,
                                    "sender": msg.sender.address if msg.sender else "",
                                    "received": msg.received.strftime('%Y-%m-%d %H:%M'),
                                    "message_obj": msg,
                                }
                                print(f"üìß Email stored for approval: {msg.subject}")
                                tag_email(msg, ["pending_review"], replyTag=False)
                            else:
                                print(f"‚è≠Ô∏è  Email already in pending queue, skipping: {msg.subject}")
                        else:
                            print(json.dumps(result, indent=2))
                            handle_new_email(msg, result)
                    continue  # done with this delta item

                try:
                    unread_msgs = unread_in_conversation(folder, mailbox, conv_id)
                except Exception as e:
                    print(f"   Could not fetch unread children for {conv_id}: {e}")
                    continue

                if not unread_msgs:
                    continue

                for child in unread_msgs:
                    try:
                        child.refresh()
                    except Exception:
                        pass
                    if any((c or "").startswith("PAIRActioned") for c in (child.categories or [])):
                        continue

                    sender_addr = (child.sender.address or "").lower() if child.sender else ""
                    sender_is_staff = sender_addr in [e.lower() for e in EMAILS_TO_FORWARD]
                    is_automated_reply = bool(re.search(fr"{REPLY_ID_TAG}\s*([^\s<]+)", child.body or "", flags=re.I|re.S))
                    if sender_is_staff and is_automated_reply and not any((c or "").startswith("PAIRActioned") for c in (child.categories or [])):
                        handle_internal_reply(child)
                        continue

                    body_to_analyze = get_clean_message_text(child)
                    print(f"\nNEW:  [{name}] {child.received.strftime('%Y-%m-%d %H:%M')} | "
                          f"{child.sender.address if child.sender else 'UNKNOWN'} | {child.subject}")
                    result = classify_email(child.subject, body_to_analyze)
                    print(json.dumps(result, indent=2))

                    if HUMAN_CHECK:
                        email_id = child.object_id
                        if email_id not in pending_emails:
                            pending_emails[email_id] = {
                                "subject": child.subject,
                                "body": body_to_analyze,
                                "classification": result,
                                "sender": child.sender.address if child.sender else "",
                                "received": child.received.strftime('%Y-%m-%d %H:%M'),
                                "message_obj": child,
                            }
                            print(f"üìß Email stored for approval: {child.subject}")
                            tag_email(child, ["pending_review"], replyTag=False)
                        else:
                            print(f"‚è≠Ô∏è  Email already in pending queue, skipping: {child.subject}")
                    else:
                        handle_new_email(child, result)
                # ==== END per-item logic ====

            params = None  # after first request, Graph returns absolute nextLink/deltaLink
            next_url = data.get("@odata.nextLink")
            if data.get("@odata.deltaLink"):
                final_delta_link = data["@odata.deltaLink"]

        print(f"DIAGNOSTIC [{name}]: Processed {total_changed} changed item(s). Final delta: {bool(final_delta_link)}")
        return final_delta_link or delta_token_url

    except Exception as e:
        print(f" Error accessing {name}: {e}")
        return delta_token_url or final_delta_link

# -------------------------------
# ACTIONS / HELPERS
# -------------------------------
def handle_new_email(msg, result):
    clear_pending_tag(msg)  # UPDATED: fixed below
    categories = result.get("categories", [])
    recipients_set = set(result.get("all_recipients", []))
    name_sender = result.get("name_sender")

    tag_email(msg, categories, replyTag=False)
    handle_emails(categories, result, recipients_set, msg, name_sender)

    if recipients_set:
        fwd = msg.forward()
        recipients_list = list(recipients_set)
        fwd.to.add(recipients_list)
        forwarded_recipients[msg.object_id] = recipients_list
        instruction_html = f"""<div style="display:none;">{REPLY_ID_TAG}{msg.object_id}</div>"""
        fwd.body = "Please press 'Reply All,' and reply to info@mlfa.org. You're email will automatically be sent to the correct person. " + instruction_html
        fwd.body_type = 'HTML'
        fwd.send()

    if not set(categories).issubset(NONREAD_CATEGORIES):
        mark_as_read(msg)

def get_time_based_greeting(name_sender):
    if name_sender and name_sender != "Sender":
        return f"Dear {name_sender},"
    current_hour = datetime.now().hour
    if 5 <= current_hour < 12:
        return "Good morning,"
    elif 12 <= current_hour < 17:
        return "Good afternoon,"
    elif 17 <= current_hour < 21:
        return "Good evening,"
    else:
        return "Good morning,"

def handle_emails(categories, result, recipients_set, msg, name_sender):
    for category in categories:
        if category == "legal":
            reply_message = msg.reply(to_all=False)
            needs_personal = result.get("needs_personal_reply", False)
            greeting = get_time_based_greeting(name_sender)
            if needs_personal:
                reply_message.body = f"""
                    <p>{greeting}</p>
                    <p>Thank you for contacting the Muslim Legal Fund of America (MLFA). 
                    We are grateful that you reached out and placed your trust in us to potentially support your legal matter.</p>
                    <p>If you have not already done so, please submit a formal application for legal assistance through our website:<br>
                    <a href="https://mlfa.org/application-for-legal-assistance/">https://mlfa.org/application-for-legal-assistance/</a></p>
                    <p>Once submitted, our team will carefully review your application and follow up with next steps. 
                    If you have any questions about the application process or need help completing it, please don't hesitate to reach out.</p>
                    <p>We appreciate your patience as we work through applications, and we look forward to learning more about how we might be able to help.</p>
                    <p>Warm regards,<br>
                    The MLFA Team<br>
                    Muslim Legal Fund of America</p>
                """
                reply_message.body_type = "HTML"
            else:
                reply_message.body = f"""
                    <p>{greeting}</p>
                    <p>Thank you for contacting the Muslim Legal Fund of America (MLFA).</p>
                    <p>If you have not already done so, please submit a formal application for legal assistance 
                    through our website:<br>
                    <a href="https://mlfa.org/application-for-legal-assistance/">https://mlfa.org/application-for-legal-assistance/</a></p>
                    <p>This ensures our legal team has the information needed to review your case promptly.</p>
                    <p>Sincerely,<br>
                    The MLFA Team</p>
                """
                reply_message.body_type = "HTML"
            reply_message.send()
            inbox = mailbox.inbox_folder()
            try:
                apply_folder = inbox.get_folder(folder_name="Apply for help")
                print("Moving to Apply for help folder.")
                msg.move(apply_folder)
            except Exception as e:
                print(f"‚ö†Ô∏è Could not move to Apply for help folder: {e}")

        elif category == "donor":
            recipients_set.update([f"{EMAILS_TO_FORWARD[0]}", f"{EMAILS_TO_FORWARD[1]}"])
            inbox = mailbox.inbox_folder()
            try:
                donor_folder = inbox.get_folder(folder_name="Doner_Related")  # Keep as-is; verify name in tenant
                print("Moving to Doner_Related folder.")
                msg.move(donor_folder)
            except Exception as e:
                print(f"‚ö†Ô∏è Could not move to Doner_Related folder: {e}")

        elif category == "sponsorship":
            recipients_set.update([f"{EMAILS_TO_FORWARD[2]}", f"{EMAILS_TO_FORWARD[3]}"])

        elif category == "organizational":
            recipients_set.update([f"{EMAILS_TO_FORWARD[2]}", f"{EMAILS_TO_FORWARD[3]}"])
            inbox = mailbox.inbox_folder()
            try:
                org_folder = inbox.get_folder(folder_name="Organizational inquiries")
                print("Moving to Organizational inquiries folder.")
                msg.move(org_folder)
            except Exception as e:
                print(f"‚ö†Ô∏è Could not move to Organizational inquiries folder: {e}")

        elif category == "volunteer":
            reply_message = msg.reply(to_all=False)
            greeting = get_time_based_greeting(name_sender)
            reply_message.body = f"""
                <p>{greeting}</p>
                <p>Thank you for your interest in volunteering with the Muslim Legal Fund of America (MLFA)!</p>
                <p>We are grateful for your willingness to support our mission of providing legal assistance to Muslims in need. To get started with the volunteer process, please complete our volunteer application form:</p>
                <p><a href="https://forms.office.com/Pages/ResponsePage.aspx?id=oiB_iSDzkUu20kpWPbd_DnxSOj2KmWxOomg5Rm0KtBNUMElYQkdOQUU2WUxLTlNHMkY4S0tFOU1XViQlQCN0PWcu">MLFA Volunteer Application Form</a></p>
                <p>Once you submit the form, our team will review your application and follow up with next steps about volunteer opportunities that match your skills and interests.</p>
                <p>Thank you again for your support!</p>
                <p>Best regards,<br>
                The MLFA Team<br>
                Muslim Legal Fund of America</p>
            """
            reply_message.body_type = "HTML"
            reply_message.send()
            inbox = mailbox.inbox_folder()
            try:
                volunteer_folder = inbox.get_folder(folder_name="Volunteer")
                print("Moving to Volunteer folder.")
                msg.move(volunteer_folder)
            except Exception as e:
                print(f"‚ö†Ô∏è Could not move to Volunteer folder: {e}")

        elif category == "internship":
            recipients_set.update([f"{EMAILS_TO_FORWARD[5]}"])
            inbox = mailbox.inbox_folder()
            try:
                internship_folder = inbox.get_folder(folder_name="Internship")
                print("Moving to Internship folder.")
                msg.move(internship_folder)
            except Exception as e:
                print(f"‚ö†Ô∏è Could not move to Internship folder: {e}")

        elif category == "job_application":
            recipients_set.update([f"{EMAILS_TO_FORWARD[6]}"])
            inbox = mailbox.inbox_folder()
            try:
                job_folder = inbox.get_folder(folder_name="Job_Application")
                print("Moving to Job_Application folder.")
                msg.move(job_folder)
            except Exception as e:
                print(f"‚ö†Ô∏è Could not move to Job_Application folder: {e}")

        elif category == "fellowship":
            recipients_set.update([f"{EMAILS_TO_FORWARD[5]}"])
            inbox = mailbox.inbox_folder()
            try:
                fellowship_folder = inbox.get_folder(folder_name="Fellowship")
                print("Moving to Fellowship folder.")
                msg.move(fellowship_folder)
            except Exception as e:
                print(f"‚ö†Ô∏è Could not move to Fellowship folder: {e}")

        elif category == "media":
            recipients_set.update([f"{EMAILS_TO_FORWARD[7]}"])
            inbox = mailbox.inbox_folder()
            try:
                media_folder = inbox.get_folder(folder_name="Media")
                print("Moving to Media folder.")
                msg.move(media_folder)
            except Exception as e:
                print(f"‚ö†Ô∏è Could not move to Media folder: {e}")

        elif category == "marketing":
            inbox = mailbox.inbox_folder()
            try:
                sales_folder = inbox.get_folder(folder_name="Sales emails")
                print("Moving to Sales emails folder.")
                msg.move(sales_folder)
            except Exception as e:
                print(f"‚ö†Ô∏è Could not move to Sales emails folder: {e}")

        elif category == "cold_outreach":
            inbox = mailbox.inbox_folder()
            try:
                irrelevant_folder = inbox.get_folder(folder_name="Irrelevant")
                cold_outreach_folder = irrelevant_folder.get_folder(folder_name="Cold_Outreach")
                print("Moving to Irrelevant/Cold_Outreach folder.")
                msg.move(cold_outreach_folder)
            except Exception as e:
                print(f"‚ö†Ô∏è Could not move to Irrelevant/Cold_Outreach folder: {e}")

        elif category == "spam":
            inbox = mailbox.inbox_folder()
            try:
                irrelevant_folder = inbox.get_folder(folder_name="Irrelevant")
                spam_folder = irrelevant_folder.get_folder(folder_name="Spam")
                print("Moving to Irrelevant/Spam folder.")
                msg.move(spam_folder)
            except Exception as e:
                print(f"‚ö†Ô∏è Could not move to Irrelevant/Spam folder: {e}")

        elif category == "newsletter":
            inbox = mailbox.inbox_folder()
            try:
                for_reference_folder = inbox.get_folder(folder_name="For reference")
                newsletter_folder = for_reference_folder.get_folder(folder_name="subscriptions and newsletters")
                print("Moving to For reference/subscriptions and newsletters folder.")
                msg.move(newsletter_folder)
            except Exception as e:
                print(f"‚ö†Ô∏è Could not move to For reference/subscriptions and newsletters folder: {e}")

        elif category == "irrelevant_other":
            inbox = mailbox.inbox_folder()
            try:
                irrelevant_folder = inbox.get_folder(folder_name="Irrelevant")
                other_folder = irrelevant_folder.get_folder(folder_name="Other")
                print("Moving to Irrelevant/Other folder.")
                msg.move(other_folder)
            except Exception as e:
                print(f"‚ö†Ô∏è Could not move to Irrelevant/Other folder: {e}")

def tag_email(msg, categories, replyTag):
    existing = set((msg.categories or []))
    new_tags = set()
    for c in categories or []:
        c = (c or "").strip()
        if not c:
            continue
        if replyTag:
            new_tags.add(f"PAIRActioned/replied/{c}")
        else:
            if c in ('spam', 'cold_outreach', 'newsletter'):
                new_tags.add(f"PAIRActioned/irrelevant/{c}")
            else:
                new_tags.add(f"PAIRActioned/{c}")
    new_tags.add("PAIRActioned")
    merged = existing.union(new_tags)
    if merged != existing:
        msg.categories = sorted(merged)
        msg.save_message()

def clear_pending_tag(msg):
    # UPDATED: actually removes pending tags
    try:
        cats = set(msg.categories or [])
        cats.discard("pending_review")
        cats = {c for c in cats if not c.startswith("PAIRActioned/pending_review")}
        msg.categories = sorted(cats)
        msg.save_message()
        print("removed the tag")
    except Exception as e:
        print(f"could not remove the tag: {e}")

def mark_as_read(msg):
    print("   Marking email as read...")
    try:
        msg.mark_as_read()
        print("   Marked as read")
    except Exception as e:
        print(f"    Could not mark as read: {e}")

def handle_internal_reply(msg):
    print(f"\nREPLY DETECTED: From {msg.sender.address} | {msg.subject}")
    body_parts = msg.body.split(REPLY_ID_TAG)
    if len(body_parts) < 2:
        print(" ERROR: Could not find the reply id, therefore, we cannot reply. ")
        return

    html_chunk = body_parts[0]
    soup = BeautifulSoup(html_chunk, 'html.parser')
    reply_content = str(soup)

    if not reply_content:
        print("   WARNING: Reply appears to be empty. Not sending. ")
        return

    match = re.search(f"{REPLY_ID_TAG}(.+?)</", msg.body)
    if not match:
        print("   ERROR: Could not find the original message ID.")
        return
    original_message_id = match.group(1).strip()

    try:
        original_msg = mailbox.get_message(original_message_id)
        other_forwardees = []
        sender_email = (msg.sender.address or "").lower()
        if original_message_id in forwarded_recipients:
            all_recipients = forwarded_recipients[original_message_id]
            other_forwardees = [email for email in all_recipients if email.lower() != sender_email]
            print(f"   Found recipients: {all_recipients}, will CC: {other_forwardees}")

        final_reply = original_msg.reply(to_all=False)
        final_reply.body = reply_content
        final_reply.body_type = "HTML"

        if other_forwardees:
            for cc_email in other_forwardees:
                final_reply.cc.add(cc_email)
            print(f"   Sent reply to original sender: {original_msg.sender.address}, CC'd: {other_forwardees}")
        else:
            print(f"   Sent reply to original sender: {original_msg.sender.address}")

        final_reply.send()
    except Exception as e:
        print(f"   ERROR: Could not send final reply. Error: {e}")
        return

    msg.mark_as_read()
    print("   Cleanup complete. Reply process finished.")

def newest_unread_in_conversation(folder, mailbox, conversation_id):
    if not conversation_id:
        return None
    q = (mailbox.new_query()
         .on_attribute('conversationId').equals(conversation_id)
         .chain('and').on_attribute('isRead').equals(False)
         .order_by('receivedDateTime', ascending=False)
         .select(['id','conversationId','internetMessageId','isRead','receivedDateTime','from','sender','subject','categories','uniqueBody','body']))
    items = list(folder.get_messages(query=q, limit=1, order_by='receivedDateTime desc'))
    if not items:
        return None
    msg = items[0]
    try: msg.refresh()
    except Exception: pass
    return msg

def unread_in_conversation(folder, mailbox, conversation_id, page_limit=30):
    if not conversation_id:
        return []
    q = (mailbox.new_query()
         .on_attribute('conversationId').equals(conversation_id)
         .select(['id','conversationId','internetMessageId','isRead','receivedDateTime','from','sender','subject','categories','uniqueBody','body']))
    items = list(folder.get_messages(query=q, limit=page_limit))
    unread = [m for m in items if not getattr(m, 'is_read', False)]
    unread.sort(key=lambda m: m.received or m.created)
    for m in unread:
        try: m.refresh()
        except: pass
    return unread

def get_clean_message_text(msg):
    QUOTE_SEPARATORS = [
        r'^\s*On .* wrote:\s*$',
        r'^\s*From:\s.*$',
        r'^\s*-----Original Message-----\s*$',
        r'^\s*De:\s.*$',
        r'^\s*Sent:\s.*$',
        r'^\s*To:\s.*$',
    ]
    def strip_quoted_reply(html_or_text: str) -> str:
        if not html_or_text:
            return ""
        text = html_or_text
        try:
            soup = BeautifulSoup(html_or_text, 'html.parser')
            for sel in ['blockquote','div.gmail_quote','div[type=cite]','div.moz-cite-prefix','div.OutlookMessageHeader']:
                for node in soup.select(sel):
                    node.decompose()
            text = soup.get_text("\n")
        except Exception:
            pass
        lines = [ln.rstrip() for ln in text.splitlines()]
        out = []
        for ln in lines:
            if ln.strip().startswith('>'):
                break
            if any(re.match(pat, ln, flags=re.IGNORECASE) for pat in QUOTE_SEPARATORS):
                break
            out.append(ln)
        return "\n".join(out).strip()[:8000]

    body = getattr(msg, 'unique_body', None) or getattr(msg, 'body', None) or ""
    return strip_quoted_reply(body)

# -------------------------------
# DELTA TOKENS (load)
# -------------------------------
inbox_delta, junk_delta = load_last_delta()

# -------------------------------
# WEB INTERFACE
# -------------------------------
from web_interface import app, create_email_routes, start_web_server
create_email_routes(pending_emails, handle_new_email, mailbox, mark_as_read)
start_web_server()
print(f"Monitoring inbox + junk for: {EMAIL_TO_WATCH} ‚Ä¶ Ctrl-C to stop.")
print(f"üìß Approval hub available at: http://localhost:5000")

# -------------------------------
# RE-AUTH (proactive + reactive)
# -------------------------------
def reconnect_account():
    """Re-authenticate and reconnect to mailbox"""
    global account, mailbox, inbox_folder, junk_folder, last_auth_time

    print("üîÑ Re-authenticating with Microsoft Graph API...")
    try:
        if IS_PRODUCTION and CLIENT_SECRET:
            credentials = (CLIENT_ID, CLIENT_SECRET)
            account = Account(credentials, auth_flow_type="credentials", tenant_id=TENANT_ID)
            account.authenticate()
        else:
            credentials = (CLIENT_ID, None)
            token_backend = FileSystemTokenBackend(token_path=".", token_filename="o365_token.txt")
            account = Account(credentials, auth_flow_type="authorization", token_backend=token_backend, tenant_id=TENANT_ID)
            account.authenticate(scopes=['basic', 'message_all'])

        mailbox = account.mailbox(resource=EMAIL_TO_WATCH)
        inbox_folder = mailbox.inbox_folder()
        junk_folder = mailbox.junk_folder()

        print("‚úÖ Successfully re-authenticated!")
        last_auth_time = time.time()  # UPDATED: reset auth age
        return True
    except Exception as e:
        print(f"‚ùå Re-authentication failed: {e}")
        return False

# -------------------------------
# MAIN LOOP
# -------------------------------
consecutive_errors = 0
last_successful_check = time.time()

while True:
    try:
        print(f"üîÑ Checking for new emails... (Pending: {len(pending_emails)})")

        # UPDATED: proactive re-auth every ~45 minutes
        if time.time() - last_auth_time > 2700:
            print("üîê Proactive re-auth (token nearing expiry)‚Ä¶")
            if not reconnect_account():
                print("üò¥ Re-auth failed; sleeping 60s.")
                time.sleep(60)
                continue

        # Safety: if no successful checks in 1 hour, force re-auth
        if time.time() - last_successful_check > 3600:
            print("‚ö†Ô∏è No successful checks in 1 hour, forcing re-authentication...")
            reconnect_account()

        inbox_delta = process_folder(inbox_folder, "INBOX", inbox_delta)
        junk_delta  = process_folder(junk_folder,  "JUNK",  junk_delta)

        print(f"DEBUG: Current directory is: {os.getcwd()}")
        save_last_delta(inbox_delta, junk_delta)

        consecutive_errors = 0
        last_successful_check = time.time()

    except Exception as e:
        consecutive_errors += 1
        print(f"‚ùå Error in main loop (attempt {consecutive_errors}): {e}")

        if consecutive_errors >= 3:
            print("‚ö†Ô∏è Multiple consecutive errors detected, attempting to reconnect...")
            if reconnect_account():
                consecutive_errors = 0
            else:
                print("üò¥ Waiting 60 seconds before retry...")
                time.sleep(60)

        # UPDATED: small randomized backoff to avoid hot loops
        sleep_s = 5 + int(5 * random.random())
        print(f"‚è≥ Backing off {sleep_s}s‚Ä¶")
        time.sleep(sleep_s)

    time.sleep(10)
